Na podstawie dostarczonych dokument√≥w przeanalizowa≈Çem kod i przygotowa≈Çem zmiany potrzebne do poprawnego dzia≈Çania funkcji przeszukiwania folder√≥w z modelami. Oto niezbƒôdne modyfikacje:
Zmiany w pliku generate_config.py
pythondef generate_config(gltf_file):
    """Generuje plik konfiguracyjny dla modelu GLTF"""
    # Tworzenie katalogu dla modelu je≈õli nie istnieje
    model_dir = gltf_file.parent
    if not model_dir.exists():
        model_dir.mkdir(parents=True)

    # Tworzenie domy≈õlnej konfiguracji
    config = {
        "center": {"x": True, "y": True, "z": True},
        "position": {
            "method": "floor",  # Mo≈ºliwe warto≈õci: "floor", "center", "topEdge"
            "value": 0,
            "yOffset": 0,  # Dodanie brakujƒÖcego parametru yOffset
        },
        "scale": {
            "method": "fixed",  # Zmiana z "auto" na "fixed" zgodnie z plikiem config.json
            "fixedScale": 0.025,  # Zmiana warto≈õci zgodnie z plikiem config.json
        },
        "rotation": {
            "x": 0,  # Obr√≥t wok√≥≈Ç osi X w stopniach
            "y": 0,  # Obr√≥t wok√≥≈Ç osi Y w stopniach
            "z": 0,  # Obr√≥t wok√≥≈Ç osi Z w stopniach
        },
    }

    # Zapisanie konfiguracji do pliku
    config_path = model_dir / "config.json"
    with open(config_path, "w", encoding="utf-8") as f:
        json.dump(config, f, indent=4)

    print(f"Wygenerowano konfiguracjƒô dla {gltf_file.name}")
Zmiany w pliku script.js
1. Modyfikacja funkcji scanModelsDirectory
javascript// Funkcja przeszukujƒÖca folder w poszukiwaniu modeli
async function scanModelsDirectory() {
  try {
    const models = [];

    // Funkcja pomocnicza do przeszukiwania podfolder√≥w
    async function scanDirectory(directory) {
      try {
        // Dodajemy trailing slash je≈õli go nie ma
        if (!directory.endsWith('/')) {
          directory += '/';
        }

        const response = await fetch(directory);
        if (!response.ok) {
          console.warn(`‚ö†Ô∏è Nie mo≈ºna otworzyƒá katalogu ${directory}`);
          return;
        }

        const text = await response.text();
        const parser = new DOMParser();
        const html = parser.parseFromString(text, 'text/html');

        // Znajd≈∫ wszystkie linki do plik√≥w
        const links = Array.from(html.querySelectorAll('a'))
          .map((a) => a.getAttribute('href'))
          .filter((href) => href && !href.startsWith('?') && href !== '../');

        for (const link of links) {
          const fullPath = `${directory}${link}`;

          // Je≈õli to folder, przeszukaj go rekurencyjnie
          if (link.endsWith('/')) {
            await scanDirectory(fullPath);
          }
          // Je≈õli to plik modelu, dodaj go do listy
          else if (
            link.toLowerCase().endsWith('.glb') ||
            link.toLowerCase().endsWith('.gltf')
          ) {
            const modelName = link
              .split('/')
              .pop()
              .replace(/\.(glb|gltf)$/i, '');
            const modelPath = fullPath;

            models.push({
              name: modelName,
              path: modelPath,
              directory: directory,
            });
            
            // Sprawdzenie czy istnieje plik config.json dla modelu
            try {
              const configPath = `${directory}config.json`;
              const configResponse = await fetch(configPath, { method: 'HEAD' });
              
              // Je≈õli plik config.json nie istnieje, wygeneruj go
              if (!configResponse.ok) {
                console.log(`‚ö†Ô∏è Brak pliku konfiguracyjnego dla ${modelName}, generujƒô domy≈õlny...`);
                
                // U≈ºywamy domy≈õlnej konfiguracji z pliku config.json
                const defaultConfig = {
                  "center": {"x": true, "y": true, "z": true},
                  "position": {
                    "method": "floor",
                    "value": 0,
                    "yOffset": 0
                  },
                  "scale": {
                    "method": "fixed", 
                    "fixedScale": 0.025
                  },
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  }
                };
                
                // Zapisz domy≈õlnƒÖ konfiguracjƒô dla modelu
                // Implementacja zapisu po stronie klienta nie jest mo≈ºliwa ze wzglƒôd√≥w bezpiecze≈Ñstwa
                // W praktyce nale≈ºa≈Çoby u≈ºyƒá endpointu API lub generowaƒá pliki po stronie serwera
                console.log(`‚ÑπÔ∏è Konfiguracja dla ${modelName} powinna zostaƒá utworzona na serwerze`);
              }
            } catch (configError) {
              console.error(`‚ùå B≈ÇƒÖd sprawdzania pliku config.json dla modelu ${modelName}:`, configError);
            }
          }
        }
      } catch (error) {
        console.error(
          `‚ùå B≈ÇƒÖd podczas skanowania katalogu ${directory}:`,
          error
        );
      }
    }

    // Rozpocznij skanowanie od g≈Ç√≥wnego katalogu models
    await scanDirectory('models/');

    console.log('‚úÖ Znaleziono modele:', models);
    return models;
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd podczas skanowania katalog√≥w modeli:', error);
    return [];
  }
}
2. Funkcja do aktualizacji interfejsu na podstawie znalezionych modeli
javascript// Aktualizacja interfejsu u≈ºytkownika po znalezieniu modeli
function updateModelsList(models) {
  const modelsListElement = document.getElementById('modelsList');
  if (!modelsListElement) {
    console.error('‚ùå Nie znaleziono elementu listy modeli w DOM');
    return;
  }

  // Wyczy≈õƒá listƒô modeli
  modelsListElement.innerHTML = '';

  if (models.length === 0) {
    const emptyMessage = document.createElement('div');
    emptyMessage.className = 'error';
    emptyMessage.textContent = 'Nie znaleziono ≈ºadnych modeli 3D';
    modelsListElement.appendChild(emptyMessage);
    return;
  }

  // Sortuj modele alfabetycznie wed≈Çug nazwy
  models.sort((a, b) => a.name.localeCompare(b.name));

  // Dodaj ka≈ºdy model do listy
  models.forEach((modelInfo) => {
    const li = document.createElement('li');
    const a = document.createElement('a');
    a.href = '#';
    a.textContent = modelInfo.name;
    a.dataset.path = modelInfo.path;
    a.addEventListener('click', (e) => {
      e.preventDefault();
      
      // Usu≈Ñ klasƒô active ze wszystkich link√≥w
      document.querySelectorAll('.models-list a').forEach(link => {
        link.classList.remove('active');
      });
      
      // Dodaj klasƒô active do klikniƒôtego linku
      e.target.classList.add('active');
      
      // Za≈Çaduj model
      loadModel(modelInfo.path);
    });
    li.appendChild(a);
    modelsListElement.appendChild(li);
  });
}
3. Modyfikacja funkcji loadModelConfig
javascript// Funkcja ≈ÇadujƒÖca konfiguracjƒô modelu
async function loadModelConfig(modelDir) {
  try {
    console.log(`üîç Pr√≥ba ≈Çadowania konfiguracji z: ${modelDir}/config.json`);
    const response = await fetch(`${modelDir}/config.json`);
    if (!response.ok) {
      console.warn(
        `‚ö†Ô∏è Nie znaleziono pliku konfiguracyjnego dla ${modelDir}, u≈ºywam domy≈õlnych ustawie≈Ñ`
      );
      return {
        center: { x: true, y: true, z: true },
        position: {
          method: 'floor',
          value: 0,
          yOffset: 0
        },
        scale: {
          method: 'fixed',
          fixedScale: 0.025
        },
        rotation: {
          x: 0,
          y: 0,
          z: 0
        }
      };
    }

    const config = await response.json();
    console.log(`‚úÖ Za≈Çadowano konfiguracjƒô dla ${modelDir}:`, config);
    modelConfigs.set(modelDir, config);
    return config;
  } catch (error) {
    console.error(`‚ùå B≈ÇƒÖd ≈Çadowania konfiguracji dla ${modelDir}:`, error);
    return {
      center: { x: true, y: true, z: true },
      position: {
        method: 'floor',
        value: 0,
        yOffset: 0
      },
      scale: {
        method: 'fixed',
        fixedScale: 0.025
      },
      rotation: {
        x: 0,
        y: 0,
        z: 0
      }
    };
  }
}
4. Modyfikacja funkcji loadModel uwzglƒôdniajƒÖca parametr yOffset
javascript// Funkcja do ≈Çadowania modelu
async function loadModel(modelPath) {
  if (!modelPath) {
    console.warn('‚ö†Ô∏è Nie podano ≈õcie≈ºki do modelu');
    return;
  }

  console.log(`üîÑ ≈Åadowanie modelu: ${modelPath}`);

  if (model) {
    scene.remove(model);
    if (model.boundingBoxHelper) {
      scene.remove(model.boundingBoxHelper);
    }
  }

  currentModelPath = modelPath;
  const modelDir = modelPath.substring(0, modelPath.lastIndexOf('/') + 1);

  try {
    // ≈Åadowanie konfiguracji modelu
    const config = await loadModelConfig(modelDir);
    console.log(`üìã Konfiguracja modelu:`, config);

    const loader = new THREE.GLTFLoader();
    const gltf = await loader.loadAsync(modelPath);
    model = gltf.scene;

    // Centrowanie modelu zgodnie z konfiguracjƒÖ
    if (config.center) {
      const box = new THREE.Box3().setFromObject(model);
      const size = new THREE.Vector3();
      box.getSize(size);
      const center = new THREE.Vector3();
      box.getCenter(center);

      if (config.center.x) {
        model.position.x = -center.x;
      }
      if (config.center.y) {
        model.position.y = -center.y;
      }
      if (config.center.z) {
        model.position.z = -center.z;
      }
    }

    // Zastosowanie rotacji zgodnie z konfiguracjƒÖ
    if (config.rotation) {
      model.rotation.x = THREE.MathUtils.degToRad(config.rotation.x || 0);
      model.rotation.y = THREE.MathUtils.degToRad(config.rotation.y || 0);
      model.rotation.z = THREE.MathUtils.degToRad(config.rotation.z || 0);
    }

    // Zastosowanie skalowania zgodnie z konfiguracjƒÖ
    if (config && config.scale) {
      if (config.scale.method === 'fixed') {
        const scale = config.scale.fixedScale || 0.025;
        console.log(`üîç U≈ºywam sta≈Çej skali: ${scale} (metoda: fixed)`);
        model.scale.set(scale, scale, scale);
      } else if (config.scale.method === 'auto') {
        // Najpierw obliczamy bounding box dla oryginalnego modelu
        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3();
        box.getSize(size);
        
        // Wybierz najwiƒôkszy wymiar jako referencyjny
        const maxDimension = Math.max(size.x, size.y, size.z);
        const targetSize = config.scale.targetSize || 100;
        
        // Ogranicz skalƒô do min/max je≈õli okre≈õlono
        let scale = targetSize / maxDimension;
        
        if (config.scale.maxSize && (targetSize > config.scale.maxSize)) {
          scale = config.scale.maxSize / maxDimension;
        }
        
        if (config.scale.minSize && (targetSize < config.scale.minSize)) {
          scale = config.scale.minSize / maxDimension;
        }
        
        console.log(`üîç U≈ºywam automatycznej skali: ${scale} (metoda: auto, targetSize: ${targetSize})`);
        model.scale.set(scale, scale, scale);
      }
    }

    // Obliczenie bounding boxa po zastosowaniu skali i rotacji
    const box = new THREE.Box3().setFromObject(model);

    // Zastosowanie metody ustawiania pozycji
    if (config.position) {
      const yOffset = config.position.yOffset || 0;
      
      switch (config.position.method) {
        case 'floor':
          // Najni≈ºszy punkt modelu na poziomie pod≈Çogi + offset
          model.position.y = -box.min.y + yOffset;
          break;
        case 'center':
          // ≈örodek modelu na poziomie pod≈Çogi + offset
          const height = box.max.y - box.min.y;
          model.position.y = height / 2 + yOffset;
          break;
        case 'topEdge':
          // G√≥rna krawƒôd≈∫ modelu na okre≈õlonej wysoko≈õci
          const value = config.position.value || 0;
          model.position.y = value - box.max.y + yOffset;
          break;
        default:
          // Domy≈õlnie: najni≈ºszy punkt na poziomie pod≈Çogi
          model.position.y = -box.min.y + yOffset;
      }
    }

    scene.add(model);

    // Dodanie wizualizacji bounding boxa
    model.boundingBoxHelper = createBoundingBoxHelper(model);
    scene.add(model.boundingBoxHelper);

    // Ustawienie widoczno≈õci bounding boxa zgodnie z globalnym ustawieniem
    const showBoundingBoxButton = document.getElementById('showBoundingBox');
    if (showBoundingBoxButton) {
      model.boundingBoxHelper.visible = showBoundingBoxButton.classList.contains('active');
    } else {
      model.boundingBoxHelper.visible = false;
    }
    
    console.log(`‚úÖ Model za≈Çadowany: ${modelPath}`);
  } catch (error) {
    console.error('‚ùå B≈ÇƒÖd podczas ≈Çadowania modelu:', error);
  }
}
5. Modyfikacja funkcji init
javascript// W funkcji init() zamie≈Ñ obecny kod ≈Çadowania modeli na:
async function init() {
  // ... istniejƒÖcy kod ...
  
  // Za≈Çadowanie listy modeli
  console.log('üîç Skanowanie folder√≥w w poszukiwaniu modeli...');
  const models = await scanModelsDirectory();
  updateModelsList(models);
  
  // ... istniejƒÖcy kod ...
}
Modyfikacja pliku .gitignore
Aby umo≈ºliwiƒá ≈õledzenie plik√≥w modelowych, nale≈ºy usunƒÖƒá lub zmodyfikowaƒá te linie:
# Large files
*.glb
*.gltf
Po usuniƒôciu tych linii modele GLTF i GLB bƒôdƒÖ uwzglƒôdniane w repozytorium. Nie zaleca siƒô jednak usuwania tych wpis√≥w, poniewa≈º pliki modelowe mogƒÖ byƒá zbyt du≈ºe dla repozytori√≥w Git. Lepszym rozwiƒÖzaniem by≈Çoby przechowywanie ich na zewnƒôtrznym serwerze.
Podsumowanie zmian:

Dostosowano skrypt generate_config.py do generowania plik√≥w konfiguracyjnych zgodnych z formatem u≈ºywanym w kodzie
Zaimplementowano poprawnƒÖ funkcjƒô scanModelsDirectory() do przeglƒÖdania katalog√≥w z modelami
Dodano funkcjƒô updateModelsList() do aktualizacji interfejsu u≈ºytkownika
Zmodyfikowano funkcjƒô loadModelConfig() do obs≈Çugi brakujƒÖcego parametru yOffset
Rozszerzono funkcjƒô loadModel() o prawid≈ÇowƒÖ obs≈Çugƒô wszystkich parametr√≥w z pliku konfiguracyjnego
Zaktualizowano funkcjƒô init() aby u≈ºywa≈Ça nowych funkcji skanowania katalog√≥w

Powy≈ºsze zmiany powinny poprawnie implementowaƒá przeszukiwanie folder√≥w i ≈Çadowanie modeli zgodnie z ich konfiguracjƒÖ.